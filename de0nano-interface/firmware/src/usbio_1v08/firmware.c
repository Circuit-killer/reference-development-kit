/**
 * Copyright (C) 2009 Ubixum, Inc. 
 * Copyright (C) 2012 Lime Microsystems Ltd.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *
 **/

#include <fx2macros.h>
#include <autovector.h> 
#include <delay.h>
#include <setupdat.h>
#include "serial1.h"
#include <fx2ints.h> 
#include <serial.h>

//USB interrupts flags
volatile bit dosud = FALSE;
volatile bit dohispeed = FALSE;
volatile bit doreset = FALSE;
volatile bit dosuspend = FALSE;

//custom functions
extern void main_loop();
extern void main_init();

void main()
{
	CPUCS = 0x10;  // 48MHz CPU clock, output to CLKOUT signal disabled.
	
	//set up USB interrupts.
	USE_USB_INTS(); //Enables interrupts generated by the USB Interface
 
	ENABLE_SUDAV(); //Enable “Setup Data Available” Interrupt Request 
	ENABLE_USBRESET(); //Enabnle the URES Interrupt Request
	ENABLE_HISPEED(); //Enabnle High speed (480 Mbits/sec) access Interrupt Request
	ENABLE_SUSPEND(); //Activates the Suspend Interrupt Request
	ENABLE_RESUME(); //Enable Resume interrupt

	main_init();

	EA = 1; // global interrupt enable
	
// iic files (c2 load) don't need to renumerate/delay
// trm 3.6
#ifndef NORENUM
	RENUMERATE();
#else
	USBCS &= ~bmDISCON; //Clearing this bit to “0”will connect to the USB bus by enabling the internal 1.5 K pull-up resistor to the D+ 
#endif

	while(TRUE) //USB interrupts flags processing
	{
		if (dosud)
		{
			dosud=FALSE;
			handle_setupdata();
		}
		if (dohispeed)
		{
			dohispeed=FALSE;
			handle_hispeed(TRUE);
		}
		if (doreset)
		{
			doreset=FALSE;
			handle_hispeed(FALSE);
		}

		if (dosuspend)
		{
			dosuspend=FALSE;
			do
			{
				WAKEUPCS |= bmWU|bmWU2; // make sure ext wakeups are cleared
				SUSPEND=1;
				PCON |= 1;
				_asm
				nop
				nop
				nop
				nop
				nop
				nop
				nop
				_endasm;
			} while ( !remote_wakeup_allowed && REMOTE_WAKEUP()); 

			// resume
			// trm 6.4
			if ( REMOTE_WAKEUP() )
			{
				delay(5);
				USBCS |= bmSIGRESUME;
				delay(15);
				USBCS &= ~bmSIGRESUME;
			}
		}

		main_loop();
	} // end while

} // end main

//ISR functions
void resume_isr() interrupt RESUME_ISR
{
	CLEAR_RESUME();
}
  
void sudav_isr() interrupt SUDAV_ISR
{
	dosud = TRUE; //set usb interrupt flag for later processing
	CLEAR_SUDAV();
}
void usbreset_isr() interrupt USBRESET_ISR
{
	doreset = TRUE; //set usb interrupt flag for later processing
	CLEAR_USBRESET();
}
void hispeed_isr() interrupt HISPEED_ISR
{
	dohispeed = TRUE; //set usb interrupt flag for later processing
	CLEAR_HISPEED();
}

void suspend_isr() interrupt SUSPEND_ISR
{
	dosuspend = TRUE; //set usb interrupt flag for later processing
	CLEAR_SUSPEND();
}
